#+title: Intel Pentium Era Before Core
#+bibliography: x86_ref.bib

* The Original Pentium (P5, March 1993)

800nm, 600nm, 350nm

- The first superscalar (multiple-issue) x86 processor.
  + Two pipelines of 5 stages
  + there are multiple execution units within one CPU core.
  + instructions are issued from a sequential instruction stream;
    the CPU dynamically checks for data dependencies between instructions at
    run time; the CPU can execute multiple instructions per clock cycle.
  + essentially all general-purpose CPU developed since 1998 are superscalar
    except some embedded processors.
  + superscalar processors are limited by the intrinsic sequentialism of the
    program logic (program logic, branch processing, dependency checking).

- Optimized microcode system and RISC-like techniques.

- Redesigned fast FPU

- 125 and 256 bits internal data paths

- 64-bit data bus, internal and external.

- separate code and data caches.

- branch prediction

- Multiprocessing support

- 4MB page size in addition to 4-KB pages

- 8 KB code cache and 8KB data cache

** Pentium MMX

350 nm - 250 nm

- MMX SIMD: 57 instructions that handle packed integer arithmetic (64-bit data with overflow saturate semantics).
  + the 8 MM0-MM7 registers are aliases for the matissa part of x87 FPU 80-bit
    registers. The disadvantage of MMX is that it cannot deal with floating
    point, and thus requires the x87 instructions to step in and take over the registers.
  + Software support is limited and as of 2000 still typically written in assembly.
  + AMD addes 3DNow! as an extension to MMX, which adds 32-bit floating-point support.

- 6-stage pipeline

* Pentium Pro (the P6 Microarchitecture or i686, 1995)

The sixth generation x86 microprocessor by Intel (CPU Family 6 displayed by =lscpu=), known for its low power
consumption, excellent integer performance and relatively high IPC. The ancestor of modern Intel
Core microarchitecture.

Decoupled, 12-stage, superpipelined implementation. P6 was one of first widely used processors to implement out-of-order execution, aside from AMD K5, Cyrix 6x86.

Its major features includes:

- ISA-decoupled dynamic execution

- 14-stage superpipelined

- 36-bit address bus but with PAE

- first x86 processor to support upgradeable microcode under BIOS or OS control.

- There is no MMX support

- in addition to two 8KB on-chip L1 cache, a 256KB level 2 cache is added to the package.

** Background

The memory speed increased little compared to the CPU speed. The CPU had to wait
for dependent data to be loaded from the memory, making the CPU underutilized.
Adding more L2 cache would be expensive.

Just like an multitasking OS can execute other tasks without busy waiting for an
I/O, a CPU can execute unrelated instructions while waiting for dependent data
to load. The CPU core executes instructions depending on their readiness to
execute and not on their original program order and thus *out-of-order execution*.

** Decoupling

It is true that the P6 microarch converts x86 instructions
into RISC-like microinstructions to be further processed by the execution units.
[[https://fanael.github.io/is-x86-risc-internally.html#p6-long-long-ago][This is not completely true for later x86 high-performance CPUs]].
Also, breaking a complex instruction into micro-instructions was nothing new
before P6. Intel's manual heavily focus on dynamic execution instead of "RISC-like internal instructions".

** Out-Of Order Execution

#+begin_src
┌─────────────┐       ┌──────────────┐       ┌──────────────┐
│             │       │              │       │              │
│             │       │   Dispatch   │       │              │
│ Fetch/Decode│       │   Execute    │       │    Retire    │
│    Unit     │       │     Unit     │       │     Unit     │
│             │       │              │       │              │
│             │       │              │       │              │
└──────┬──────┘       └────▲──────┬──┘       └───────▲──────┘
       │                   │      │                  │
       │                   │      │                  │
       │                   │      │                  │
       │                   │      │                  │
       │         ┌─────────┼──────▼─────────┐        │
       │         │                          │        │
       │         │                          │        │
       └────────►│                          ┼────────┘
                 │     Instruction Pool     │
                 │                          │
                 │                          │
                 └──────────────────────────┘
#+end_src

The three independent engines communicate via the instruction pool.

Instead of stalling over the dependent data of a certain instruction, the core
looks ahead for other instructions (20 to 30 in front of the program counter)
that could be speculatively executed, within which branches must be correctly
predicted.

The sparse number of architectural registers of x86-32 may create many false
dependencies (too few registers for too many data that are not really dependent
on each other). Register renaming separates these independent data to reduce
false dependencies. The retire unit owns the architectural registers and results
are only committed to permanent machine state.

*** Dynamic execution: How Intel Explains

#+begin_quote
Dynamic Execution technology can be summarized as optimally adjusting instruction execution by
predicting program flow, analysing the program’s dataflow graph to choose the best order to execute
the instructions, then having the ability to speculatively execute instructions in the preferred order.
The P6 dynamically adjusts its work, as defined by the incoming instruction stream, to minimize
overall execution time.[cite:@P6Tour]
#+end_quote

**** /deep branch prediction/

Decode instructions beyond branches to keep the instruction full (prediction, not execution).

**** /dynamic data flow analysis/

analysis of the flow of data through the processor to determine dependencies and to detect opportunities for out-of-order instruction execution. The out-of-order execution core can monitor many instructions and execute these instructions in the order that best optimizes the use of the processor's multiple execution units, while maintaining the data integrity. An optimized schedule of instructions is created for speculative execution.

**** /speculative execution/

The ability to execute instructions that lie beyond a conditional branch that has not yet been resolved and ultimately to commit the results in the order of the original instruction pattern.

Dispatch and execution of instructions are decoupled from the commitment of results. The results are stored in temporary registers. The /retirement unit/ searches the instruction pool for completed instructions that are not depended by other unfinished instruction or unresolved branch predictions, and commits the results of these instructions to memory or x86 registers.


"Retirement" means a micro-op completes and writes its result to reflect the
architectural state change according to the original program order. The
Retirement Unit may also send updated branch Target information to the Branch
Target Buffer. There is also the /reorder buffer/ that is responsible to hold the results of out-of-order execution.


** New Instructions

- conditional move instructions =CMOVcc= and =FCMOVcc=, conditional jump =Jcc=.
  + conditional statement with a costly conditional branch.

- =UD2= illegal instruction for developers to crash the program.

** Disadvantages

Frequent pipeline flushing when dealing with mixed code (8-bit with 16-bit, 16-bit with 32-bit), and thus not suitable for PC users, but used with 32-bit OS (NT, Unix).

* Pentium II (May 1997, 233Mhz to 450MHz, 350-180 nm)

A more consumer-oriented version of Pentium Pro, combining the P6 microarchitecture with MMX, largely a Pentium Pro.

- MMX support

- Improved 16-bit code execution performance by adding segment register caches.

- In-Package 512KB L2 cache connected by a half-frequency backside bus

** Revisions

- Klamath: 233, 266, 300 MHz at 66 Mhz FSB.

- Deschutes: 333, 266, 300 (66MT/s FSB); 350, 400, 450 (100 MT/s)
  + combined with the 440BX chipset and its derivatives.
  + =FXSAVE=, =FXRSTOR= instructions

- Tonga and Dixon, 250 and 180 nm mobile versions.

** Covington & Mendocino Celeron

- Covington (Apr. 1998): Pentium II without L2 cache with poor performance

- Mendocino (August 1998): 128KB full-speed L2 cache with great performance, from 300MHz up to 533MHz

* Pentium III (Feb. 1999 until early 2003)

Continued evolution from P6

- SSE SIMD to accelerate floating-point and parallel calculations

** Revisions

- Katmai: further development of Deschutes Pentium II.
  + 250nm process
  + 450, 500, 550, 533B (133MHz FSB), 600B (133MHz FSB)

- Coppermine (Oct. 1999):
  + On-chip L2 cache
  + 180nm process
  + 500MHz up to 1GHz

- Tualatin: (2001)
  + 130nm process
  + 1.0, 1.13, 1.2, 1.26, 1.33 and 1.4GHz
  + the basis for Pentium-III M and later Pentium-M

** Coppermine-128 Celeron

Derivative of Coppermine Pentium-III with 128KB on-chip L2 cache. 566MHz up to 1100MHz.

** Tualatin-256 Celeron (Oct. 2001)

- 100MHz bus, 256KB L2 cache.

- 130nm process

- 1.0 up to 1.4GHz, with comparable performance with Pentium 4 Willamette.

* Pentium 4 (NetBurst P68)

Like P6, NetBurst features superscalar hyper-pipelined out-of-order execution.
The front-end pipeline prefetches instructions that are likely to executed,
fetches instructions that have not been prefetched, decodes them into
micro-operations, generates microcode for complex instructions and
special-purpose code, delivers decoded instructions from the execution trace
cache and predicts branches using highly advanced algorithms.

- the first processor to implement *Simultaneous Multithreading* (Hyperthreading): issue multiple instructions from
  multiple threads in one cycle, each executing threads independently.
  + the opposite is *temporal multithreading*; multicore is chip-level multiprocessing.
  + a form of thread-level parallelism;

- Quad-pumped front-side bus: 200MHz but 4 bit per cycle

- 20-stage instruction long pipeline

- Expanded hardware registers with renaming to avoid register namespace limitations.

- /trace cache/ in the front end stores decoded sequences of micro-ops (called
  *traces*, representing prefetched branches).
  + /how it works/: The trace cache is searched for the instruction that follows the active
    branch. If the instruction also appears as the first instruction in
    pre-fetched branch, the fetch and decode of instructions from memory
    hierarchy ceases and the prefetched branch becomes the new source of instructions.
  + /why/: the trace cache addresses the issue of decoding latency and wasted decode bandwidth due to branches or branch target in the middle of cache lines.

- rapid execution engine: double pumped ALUs, at twice the rate the core clock frequency

- New cache system:
  - L1: advanced execution trace cache stores decoded instructions and removes
    decoder latency from main execution loops, integrates path of program
    execution flow into a single line;
  - L2: full-speed unified 8-way on-die Advance Transfer Cache;

- deep out-of-order speculative execution engine, up to 126 instructions in
  flight, 48 loads and 24 stores in pipeline; enhanced branch prediction capability
  + up to 6 micro-ops per cycle

** Revisions

- Willamette (2000)
  + 180nm
  + 20-stage pipeline

- Northwood (2002)
  + Hyper-threading
  + 130 nm
  + 20-stage pipeline

- Prescott (Feb. 2004)
  + SSE3 instruction set and later the EM64T (AMD64) architecture
  + 90 nm
  + 31-stage pipeline

** Celerons

Willamette-128, Northwwod-128, Prescott-256 ("Celeron D" but with a single
core), Cedar Mill-512

* Pentium D

Dual core version of the Pentium 4. The two cores are not linked together,
rather rely on the northbridge link for communication. The front side bus is
shared by the two cores.

** Revisions

- Smithfield: 90 nm, named 8xx series

- Presler: 65 nm Cedar Mill cores, named 9xx series

* Itanium (IA-64, the originally planned P7 architecture)

Intel's discontinued 64-bit architecture with no compatibility with existing x86
programs other than emulation, defeated by x86-64, originally from HP, never popular
outside enterprise servers (and even there only a fraction of market share) and high-performance computing systems.

- Merced (2001, 733 to 800 MHz): poor performance

- Itanium 2 (McKinley and Madison, 2002-2006):
  + 900 to 1667 MHz
  + 180nm to 130nm
  + replaced by AMD64 soon

- Itanium 9100 series

- Itanium 9300 (2010)

- Itanium 9500 (2012)
  + 32 nm

- Itanium 9700 (2017): a limited improvement over 9500
  + 22 nm

Major OSes offered support for Itanium, however, Linux dominated in all systems
except those of HP.

* Pentium M

An evolution of Tualatin, with the FSB of Pentium-4



- 10 or 12 stage pipeline

- Advanced Branch Prediction and Data Prefetch Logic

- SSE2

- 32KB code cache and 32KB write-back data cache; Larger On-die L2 cache (up to 2MB)

- improved branch prediction

- 130nm to 90 nm

- 5-27 W TDP

** Revisions

- Banias:
  + 24.5 watts TDP
  + 130nm
  + 900MHz to 1.7 GHz with a 400MT/s FSB.

- Dothan: Pentium M 7xx Series
  + 90 nm
  + 2NM L2 cache
  + 21 W TDP

* Enhanced Pentium M (Yonah)

The prologue of the Core microarchitecture.

Under the brand Core Solo, Core Duo (Jan. 2006, low-power dual-core), Pentium
Dual-Core, Xeon LV/ULV, Celeron M 400 (single-core). Core Solo/Duo are still
marketed as mobile processors.

- SSE3 support

- single- and dual-core with 2MB L2 cache

- 667 MT/s FSB

- 12-stage pipeline
  + 2.33-2.50GHz at maximum

- specialized bus for core-cache communication

- No x86-64 implementation until Core 2, the real Core microarchitecture

* Bibliography

#+print_bibliography:
