#+title: RISC-V Architecture

* Myth

- RISC-V is a RISC ISA and thus is fixed-length: no, it  supports optinally variable-length to both expand available instruction encoding space and to support an optional dense instruction encoding for improved performance, static code size and energy efficiency.

* Basic Terminology

- /Core/: a hardware component that contains an independent instruction fetch unit. It may have multiple RISCV-compatible hardware thread resources called /harts/.

- /Coprocessor/: a unit that is attached to a RISC-V core which contains additional architectural state and instruction-set extensions.

- /Accelerator/: a non-programmable fixed-function unit or a core that can operate autonomously, specialized for certain tasks.

- /Software Execution Environment/, /Execution Environment Interface/: execution
  environments range fromn bare-metal hardware implementations, to RISC-V OSes,
  hypervisors to RISC-V emulators. The RISC-V specification defines EEI quite
  broadly so that various CPU concepts may be applied to different implementations.
  + an EEI has *harts* (an abstract execution resource that autonomous fetches and execute RISC-V
    instructions within the execution environment)

* Instruction Set Overview

RISC-V is a family of related ISAs: four distinct base ISAs are designed in
parallel as opposed to adding on later to sit on top of another. RISCV is
designed to support customization and specialization with the differentiation of
standard encoding, reserved encoding and custom encoding.

- *base integer ISAs*, present in any implementation
  + /RV32I/, /RV64I/, /RV32E/ (embedded, for microcontrollers), /RV128I/. Any
    base ISA is not a strict subset of another so that each can be optimized
    for its needs without requiring to support all the operations needed for4
    other base ISAs.

- *optional extensions*:
  + /standard/: M (integer multiplication/division), A (atomic operations),
    F/D/Q/L (various floating-point instructions), P (packed SIMD), V (Vector),
    C (compressed instruction, 16-bit forms of common instructions)
  + /reserved/: saved for future standard
  + /custom/: never used fo4r standard extensions and available for
    vendor-specific non-standard extensions.
  + /non-conforming/: uses standard or reserved encoding for non-standard ISAs.

** Encoding

- Fix-lenght 32-bit instructions by default aligned on 32-bit boundaries

- designed to support ISA extensions with variable-length instructions with lengths of 16-bit instruction parcels.

* Memory Model

- a single byte-addressable circular space of its bitness for all memory accesses

- word = 4-bytes, halfword = 2 bytes, doubleword = 8 bytes, quadword = 16 bytes.

- the address space may contain one or more I/O devices, determined by the execution environment.

- Different harts may see different address spaces. A purely base-metal
  environment has an identical address space for all harts.

- Normally, implicit memory access is done to obtain the instruction to execute.
  Other implicit memory accesses may be possible (not to be confused with
  the load/store concept, where only instructions are discussed over)
  + implicit reads do not raise an exception and may occur arbitrarily early and speculatively.

- The EEI is responsible for memory access control.

- The memory accesses (implicit or explicit) made by a hart may appear to occur
  in a different order as perceived by another hart or by any other agent that
  can access the same memory.
  + the default memory consistency model for RISC-V is the *RISC-V Weak Memory
    Ordering*. An implementation may also implements *Total Store Ordering*.


* Exceptions, Traps, Interrupes

- /Exception/: unusual condition occurring at runtime associated with an instruction in the current RISC-V hart.

- /Interrupt/: an external asynchronous event that may cause a RISC-V hart to experience an unexpected transfer of control.

Exceptions and interrupts are events, traps are the consequences of these events.

- /trap/: the transfer of control to a trap handler caused by either an exception or an interrupt.

From the perspective of software, traps can be divided into

- /Contained traps/: visible to and handled by software.

- /Requested traps/: The trap is a synchronous exception that is an explicit call to the execution
environment requesting an action on behalf of software inside the execution environment. e.g. a syscall

- /Invisible Traps/:  handled by the execution environment.
  + e.g. emulating missing instructions, handling page faults

- /Fatal traps/: a fator failure and causes the execution environment to terminate execution.

* ISAs

There are reduced versions RV32E and RV64E of RV32I and RV64I, which have only
registers =x0= to =x16= for embedded microcontrollers (to save die area).

** RV32I and RV64I Base Integer Instruction Set

A total of around 40 instructions, enough to emulate all other instructions except the
A(tomicity) extension.

*** Programming Model

- =x0=: zero register, hardwired to be zero

- =x1=-=x31= general purpose registers
  + the standard calling convention uses =x1= to hold the return address (link
    register, x86 does not have such special a register) for a call and =x5= as an alternate link register, =x2= as the stack pointer.

- =pc=: program counter

*** Encoding and Formats

Encoding and formats are important as they dictate what instructions can do,
especially with immediates, due to the length of an instruction. Consult the ISA
manuals for full encoding specification.

*Fixed-length 32-bit instructions aligned on 32-bit boundaries*. However, RISC-V
is designed to support variable-length ISA of the multiples of 16 bits.
Currently all 32-bit instructions have their lowest two bits set to =11=.

Bit 0-7 are always the code. =rd= (destination registers) is placed at bit 7-11,
=rs1= at bit 15-19, =rs2= at bit 20-24. Immediates are always sign-extended and
the sign bit is placed at bit 31 of the instruction, and the length is either 12
or 20.

- R(egister)-type: =op rd, rs1, rs2=

- I(mmediate)-type: =op rd, rs1, imm12=
  + the resultant immediate is =imm12= sign extended to 32 bits

- S(tore)/B(ranch)-type: =op rs1, imm12(rs2)=
  + the B-type is S-type with two bits of the immediate swapped and the
    12-bit-encoded immediate is actually a 13-bit number with bit 0 equal to
    zero, to represent branch a offset in multiples of 2 since all instructions
    are aligned at least on 16-bit boundaries (for extended instructions with
    length of 16-bit multiples).
  + For S-type, the resultant immediate is =imm12= sign extended to 32 bits
  + For B-type, the resultant immediate is =imm12= shifted left by 1 and then sign extended to 32 bits

- U/J(ump)-type: =op rd, imm20=
  + the J-type is to the U-type as the B-type is to the S-type.
  + For U-type, the resultant immediate is =imm20= shifted left by 12, occupying
    the upper part.
  + for J-type, the resultant immediate is =imm20= shifted left by 1 (21 bits) and then
    sign extended.

*** Integer Computation Instruction

Register-immediate: I type format; Register-Register: R-type

- arithmetic (mostly I- or R-type): =ADDI=, =ADD=; =SUB=
  + overflow check is done with a comparison-branch instruction that compares
    the result with an operand.
  + =mv rd, rs1= implemented as =addi rd, rs1, 0=
  + =nop= implemented as =addi x0, x0, 0=, may be used to align code segments or
    leave space for inline code modifications. Although the same effect may be
    achieved via other instructions, this is the chosen canonical one (see HINT instructions).

- logical: =ANDI=, =ORI=, =XORI=; =AND=, =OR=, =XOR=
  + =NOT rd, rs= implemented =XORI rd, rs1, -1=, where -1 is all 1s).

- shifts (I-type): =SLLI=, =SRLI=; =SRAI=; =SLL=; =SRL=; =SRA=

- less-than comparison, signed and unsigned: =SLTI=, =SLTIU=; =SLT=, =SLTU=
  + =SEQZ rd, rs= (set true if equal to zero) implemented as =SLTIU rd, rs1, 1=
  + =SNEZ rd, rs= (set true if not equal to zero) implemented as =SLTU rd, x0, rs2=

- special addition: =LUI= (load upper immediate), =AUIPC= (add upper immediate to pc) (U-type): used to build 32-bit constants, with a number of
  which the upper 20 bits are explicitly encoded (=LUI=), or a number generated
  by the upper 20-bit immediate added to the =pc= (=AUIPC=).
  + the upper 20 bits in =LUI= or =AUIPC=, combined with an 12-bit immediate can
    construct a 32-bit number(absolute, or pc-relative which adds =pc= to the
    32-bit offset), and thus provides a way to construct large memory address.
  + =AUIPC= is better for obtaining the current PC with =auipc rd, 0= than
    =JAL+4= since it does not interfere with the branch predictor.

*** Control Transfer

- the target should be four-byte aligned.

- =JAL=: jump and link, target an offset of 1MB (2-bytes).

- =JALR=: jump and link register: the target is the source register offset by a 12-bit sign extended immediate.

- Branches: =BEQ=, =BNE=; =BLT=, =BLTU=; =BGE=, =BGEU=: 4KB branch range.

*** Load/Store

- Only load and store instructions access memory and arithmetic instructions only operate on CPU registers.

- little-endian or big-endian dependending on the EEI.

- Effective address: =rs1= with sign-extended 12-bit offset.

- =LW= (load word); =LH=, =LHU=; =LB=, =LBU=

- =SW=, =SH=, =SB=

** RV64I Base Integer Instruction Set

- Integer register and user address space is widened to 64 bits.

- Most integer computational instructions operate on 64-bit values.
  Additional instructions are added to provide 32-bit manipulation.

*** Integer Operations

- =ADDIW=: the result is sign-extended to fit in the 64-bit register.

- =SLLI=, =SRLI= (logic shift); =SRAI=: arithmetic right shift.

- =SLLIW=, =SRLIW=, =SRAIW=: RV64I=only instructions that operate on 32-bit values and produce signed 32-bit results.

- =LUI=: places 20-bit unsigned immdiate into bits [31-12] of the destination register place zero out all the lower bits and then sign-extend to 64 bits.

- =AUIPC=: used to build PC-relative addresses. It appends 12 low-byte zero bits to the 20-bit U-immediate,
  sign extends to 64 bits and adds it to the addres, adds it to the address of the =AUIPC= instruction and then places the result in the destination register.

*** Load/Store

- =LD=: load a 64-bit value from memory into register =rd=

- =LWU=

- =SD=

** M Standard Extension

- =MUL= (lower half); =MULH=, =MULHU=, =MULHSU= (upper half): full multiplication would be =MULH((S)H) rdh, rs1, rs2; MUL rdl, rs1, rs2=

- =MULW=

- =DIV=; =DIVU=; =DIVW=, =DIVUW=

- =REM=, =REMU=; =REMW=, =REMUW=

Full division would be =DIV(U) rdq, rs1, rs2; REM(U) rdr, rs1, rs2=.

** F Standard Extension: Single-Precision Floating-Point Computational Instructions

- =f0=-=f31= 32-bit wide register; =fscr= control and status reegsiter, which contains the operating mode and exception status of the floating-point unit.

** D Standard Extension: Double-Precision Floating-Point

=f0= through =f32= are widened to 64 bits

* ABI

** Standard ABI

*** Registers

- =x1=: =ra= (return address)

- =x2=: =sp= stack pointer

- =x3=: =gp= global pointer

- =x4=: =tp= Thread pointer

- =x5=-=x7=: =t0=-=t2=, =x28=-=x31=: =t3=-=t6= temporary registers

- =x8=-=x9=: =s0=-=s1=, =x18=-=x27=: =s2=-=s11=: callee-saved registers

- =x10=-=x17=: =a0=-=a7= argument registers

- =f0-f7=, =f28=-=f31=: temporary registers

- =f8=-=f9=, =f18=-=f27=: callee-saved registers

- =f10=-=f17=: argument registers

*** Calling Convention

**** Integer Calling Convetion

- =a0=-=a7=: for scalars smaller than XLEN.

- the stack is empty-descending and the stack pointer is aligned to a 128-bit boundary upon procedure entry.
