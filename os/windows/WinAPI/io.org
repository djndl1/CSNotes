* Filesystem

** Linking Filesystem Objects

On NTFS at least. All NTFS links are transparent to applications.

Windows shortcuts are shell links, recognized by the Windows Explorer, but not
the filesystem.

- *Hard link* (Since NT 4): more than a path referencing a single file in the same volume.
  Simply a
  directory entry for a file, without a security descriptor.
  + not applicable to folders
  + file attributes and security descriptor are shared among all hard links to
    the file.
  + =CreateHardLink= to create, =DeleteFile= to remove,

  #+begin_src shell
mklink.exe /h linkname targetpath
# W2K and XP
fsutil hardlink create linkname targetpath

# powershell
New-Item -ItemType HardLink -Path LinkPath -Target targetPath

# deletion on CMD
del linkname
  #+end_src

- *Directory Junction Point* (since Windows 2000 on NTFS and mostly legacy,
  except that it requries no admin privilege): May link directories
  on different local volumes.
  + implemented using reparse points
  + always absolute and points only to directories.
  + Safe to delete in Windows Explorer without affecting the original directory.

  #+begin_src shell
mklink.exe /j linkname targetpath

# pwsh
New-Item -ItemType Junction -Path LinkPath -Target targetPath

# for deletion on CMD
rmdir linkname #  no del
# for deletion on powershell, use .NET API, do not use Remove-Item or any its aliases
(Get-Item LinkName).Delete()
  #+end_src

- *symbolic links* (since Windows Vista): full support for corss-filesystem
  links and even SMB network path.
  + Not permitted by default (configurable in Local Security policy) for non-admin users
  + Implemented with *reparse points*, a collection of user-defined data in a
    file or a directory that is used by an app or a filesystem filter to process.
  + Safe to delete in Windows Explorer without affecting the original directory.
  + =CreateSymbolicLink()= to create
  + Junctions are processed at the server and symlinks are processed at the
    client: this might cause unexpected redirection results. However, a junction
    point points only to local folders, while symlinks permits remote folders.

  #+begin_src shell
mklink linkname targetpath

#pwsh
New-Item -ItemType SymbolicLink  -Path LinkPath -Target targetPath

# CMD, to avoid delete the original directory or file
rmdir linkname # do not use del in CMD and rmdir in Pwsh

# powershell, do not use
(Get-Item LinkName).Delete()
  #+end_src

- Mounting point
  + also implemented using reparse points

  #+begin_src shell
mountvol mountpoint \\?\volume{volumeGuid}
  #+end_src

** Use & Usage

- WinSxS uses hard links to track DLLs

- Backward compatibility
  + Some hidden links on Windows are maintained for compatibility with XP, e.g.
    =C:\Documents and Settings= to =C:\Users=, =%Userprofile%\Application Data\=
    to =%UserProfile%\AppData\Roaming=

- Program redirection
  + do not try to redirect system folders.

- Saving Storage Space

- Circumventing predefined paths
  + some programs requires a special installation path.


* [[https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file][File Naming]]
  :PROPERTIES:
  :CUSTOM_ID: file-naming
  :END:


A full pathname is either a DOS-style disk name (=DiskName:=) prefixed or a *Universal Naming
Convention* (=\\ServerName\sharename=) name. Both backslash and forward slash
are legal path separator. File names are case-insensitive but case-retaining.
Base names are seperated by a period from its extension (file type name).
Certain filenames are not allowed due to DOS compatibility.

Pathnames are subject to =MAX_PATH= length (260 currently, and the limitation may be removed
since Window 10 1607 through [[https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry][some configuration]]). Extended-length paths are
prefixed with the Win32 File namespace prefix =\\?\= (=\\?\UNC\server\share= for UNC paths) to disable any
string parsing.
Thus extended-length paths are absolute paths and do not use forward slashes as
separators, or periods to denote the current or parnent directory. Also, they
are not supported by every file I/O API.

It is acceptable to specify a period as the first character of a name.
For example, ".temp".

A file name is not relative if:
- UNC =\\=
- starts with a disk designator =C:\=. =C:tmp.txt= is a relative path
   on =C:\=.
- a single backslash
On Windows, a fully-qualified path differs from an *absolute path* (*rooted*), which starts
from the root but does not specify on which disk this root is. A program may
have different current directories on different drives on Windows.

A short 8.3 DOS-style alias is generated by Windows for a file.
A directory path cannot be longer than =MAX_PATH - 12=,

** /namespaces/
   :PROPERTIES:
   :CUSTOM_ID: namespaces
   :END:

NT namespaces and Win32 namespaces. The NT namespace was designed to be
the lowest level namespace on which other subsystem and namespaces could
exist.

The =\\.\= prefix is used to access the Win32 Device Namespaces. Most API do not
support this prefix.

Under the NT namespace, =Global??= is the Win32 namespace. Symlinks are created
to allow Win32 subsystem to access certain devices. A =\\?\GLOBALROOT\= is also
created to allow access to the true root path.

** Unicode

Windows stores the long file names on disk in Unicode.

=TCHAR= is a legacy from the transitional period and should not be used anymore,
use =wchar_t= only. Always define =UNICODE= (Win32 API) and =_UNICODE= (C
runtime, MFC etc.)


* Opening, Reading, Writing and Closing
  :PROPERTIES:
  :CUSTOM_ID: opening-reading-writing-and-closing
  :END:

Windows File API can specify share mode while Unix files are always shareable.

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew][CreateFile]], =ReOpenFile= (returns a new handle with different flags, access
rights etc.)

[[https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle][CloseHandle]]: closes and invalidates nearly all handle objects.

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile][ReadFile]]:

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile][WriteFile]]:

=GetLastError= (set by =SetLastError=) rather than =errno= ensures that
system errors are unique to the threads. =FormatMessage= turns the
message number into a meaning message.

A Windows process has three standard devices =STD_INPUT_HANDLE=,
=STD_OUTPUT_HANDLE=, =STD_ERROR_HANDLE=, retrieved by =GetStdHandle= and
redirected by =SetStdHandle=.

There are two reserved pathnames =CONIN$= and =CONOUT$= for console
input and output. Use =CreateFile= on them.

A number of filesystem management high-level (command-line tool level) functions
are also provided by Win32. =DeleteFile=, =CopyFile=, =CreateHardLink=,
=CreateSymbolicLink=, =MoveFile=, =MoveFileEx, =CreateDirectory=,
=RemoveDirectory=, =SetCurrentDirectory=, =GetCurrentDirectory=


