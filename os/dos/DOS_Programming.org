#+title: DOS Programming

* FreeDOS

** Serial Console

- start =ctty COM1= at the DOS side and start a serial port communication client
  at the client side.
  + =stty con= returns control to the graphics console.

** File Transfer To/From the VM

- [[https://www.freedos.org/books/get-started/24-guestmount-freedos/][mount the virtual disk with =guestmount=]]

- install =ssh2dos= and configure the host to support older algorithms.
  + check =sshd='s log to find out missing algorithms.
  + will no longer works with future builds of OpenSSH.

- use the kermit protocol
  + it requires both sides set up kermit and start the connection.

- the best and easiest is to set up a ftp on the host e.g. =vsftpd=. No security
  bullshit, best compatibility


* [[../../lang/c/assembly/x86_legacy.org][8086 Architecture]]

* Memory Map

#+begin_src
┌─────────────────────────────────┐ FFFFF (1M)
│                                 │
│           BIOS                  │
├─────────────────────────────────┤ E0000
│                                 │
│                                 │
│        Reserved                 │
│                                 │
├─────────────────────────────────┤ A0000 (640K)
│  Transient COMMAND.COM          │
├─────────────────────────────────┤
│                                 │
│                                 │
│                                 │
│                                 │
│     Transient Program area      │
│        (user memory)            │
│                                 │
│                                 │
│                                 │
├─────────────────────────────────┤
│   Resident COMMAND.COM          │
├─────────────────────────────────┤
│          Buffers, Drivers       │
├─────────────────────────────────┤
│                                 │
│             DOS Kernel          │
│                                 │
├─────────────────────────────────┤
│             BIOS                │
├─────────────────────────────────┤ 00400
│           Interrupt             │
│         Vector Table            │
└─────────────────────────────────┘ 00000
#+end_src

** Interrupts

One of the main purposes of interrupts is to allow CPU to respond to external
events instead of busy waiting or occasion polling.

- 256 available interrupts numbered from =0x00= through =0xFF=.

*** Categories

- *internal interrupt* :: generated internally by the CPU when certain
  conditions or errors occur.

- *external hardware interrupt* :: generated by a peripheral hardware device.

- *software interrupt* :: generated by a program to gain access to system services.

* DOS Architecture
:PROPERTIES:
:ID:       0ee575a2-a7eb-4e8e-b962-c1a282d9e28d
:END:

- *BIOS* :: an interface to the hardware at boot time and run time
  + the console
  + a generic line printer
  + the auxiliary device (usually a serial port)
  + the computer clock
  + the boot disk device
  + provides some system services

- *DOS Kernel* :: =MSDOS.SYS=, providing system services accessed by means of a
  *software interrupt*.
  + filesystem management
  + memory management
  + character device I/O
  + time/date support
  + program management
  + provides system services through =INT 21H=

- *Command Processor* :: =COMMAND.COM= the shell
  + loaded at boot time
  + has three modules
    + *resident module*: remains loaded in the memory as long as the computer is
      turned on, processing =Ctrl-Break= and =Ctrl-C= and loading the transient
      module if not loaded.
    + *initialization module*: processing =AUTOEXEC.BAT=
    + *transient module*: loaded in the high end of /user/ memory, processing
      commands and executing them.
  + can be replaced

* DOS API Programming
:PROPERTIES:
:ID:       91dd13c3-9b3f-435a-a5ab-4c3c6c546865
:END:

Most calls to the DOS API are invoked using the =INT 21H= software interrupt
with a subfunction number in the =ah= register, basically a kernel syscall.

** Keyboard

Whenever a key is pressed or released, a scan code is generated and the =0x09=
interrupt is generated. A release scan code is the press scan code with bit 7 set to 1.

Normally, the BIOS is responsible for handling the
interrupt by setting some flags (e.g. =Ctrl=, =Alt=, =Shift=), generating
another interrupt (=Ctrl-Break=, =Ctrl-C= to Int 23H, =Alt-SysReq=),
or setting the keyboard buffer by placing the key's ASCII code (0 if none) and then scan code.

DOS kernel keyboard APIs are sensitive to input redirection (=stdin= and =stdout=).

*** =Ctrl-C=, =Ctrl-Break=

Upon pressing =Ctrl-C= or =Ctrl-Break= (higher priority), DOS reads in and generates an =INT 23H=,
of which the default handler is to terminate the current process.

DOS also maintains a break flag, with the value of which being 0,
DOS only checks for a =Ctrl-Break= during certain I/O operations while the value
1 causes DOS to check every time a DOS service is called.

* BIOS Interrupt Call

The IBM PC BIOS sets up its interrupt handlers and provides basic hardware
control to the software running on the
machine, even though one may access hardware directly.

Modern OSes bypass any BIOS interrupt calls at all after startup due to real-mode
switch, limited memory address space, BIOS code performance issue, limited
functionality and compatibility issue of BIOS calls: a modern OS takes matters
in its own hands.


* Extended Memory

Any memory above 1MB under DOS, which cannot be directly accessed under real
mode or virtual x86 mode.

** Extended Memory Specification (XMS)

** DOS Protected Mode Interface (DPMI)

* DOS ABI

** Binary File Format

*** *COM*: CP/M =.COM=
  + no header, only code and data in a single segment, loaded at a preset
    address of offset 0x100 following the PSP.
  + maximum size of 0xFF00 bytes

*** *MZ*: DOS =.EXE=

Supports multiple segments to be loaded at arbitrary memory addresses and
executables greater than 64KB.

The loader patches certain operands and values at load time with the relocation
table to support relocation. The table lists all addresses of which the value needs patching.
