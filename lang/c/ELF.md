https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/

http://www.sco.com/developers/gabi/latest/contents.html

https://reverseengineering.stackexchange.com/questions/1992/what-is-plt-got

https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html

https://www.airs.com/blog/archives/38

https://wiki.gentoo.org/wiki/Hardened/Introduction_to_Position_Independent_Code

https://wiki.gentoo.org/wiki/Hardened/Position_Independent_Code_internals

An ELF file consists of 

1. ELF header

2. File data

```
ELF Header

Program header table

.text
.rodata

.data
Section header table

```

# ELF header

- `hexdump`

- `redelf -h`

- `dumpelf`

# File Data

- Program Header/Segments: An ELF file consists of zero or more segments, and describe how to create a process/memory image for runtime execution. When the kernel sees these segments, it uses them to map them into virtual address space, using the mmap(2) system call. In other words, it converts predefined instructions into a memory image.

```bash
readelf -l
```

- Section Header/Sections: used for linking and relocation

```bash
readelf -S
```

- Data

## Sections

### `.text`

### `.rodata`

### `.bss`

### `.data`

# Initialization

- The Compiler provides a static initialization function for each translation unit, and put the pointer in the `.init_array` section.

- The linker gathers together all the`.init_array` by the linker script.

- The C runtime walks through this array and call each of the initialization functions.

# Relocations:

The process of assigning load addresses for position-dependent code and data of a program and adjusting the code and data to reflect the assigned addresses.

Linkers: reads the inputs, identifies symbols and applies relocations.

- /Symbol Table/: symbols that an object file provides and needs.

- /Relocation section/ in an object file: info which the linker can utilize to find symbols and place their addresses.

# Dynamic Linking

/Procedure Linking Table/ (PLT): generated by the linker for relocatable symbols. Every call to a function goes through an entry 
in the PLT first to finally determine the address of the target function the first time the plt entry is accessed, and jump to that address.

`ldd`

- `LD_BIND_NOW`: force the resolution of the address.

- ` LD_PRELOAD`: preload symbols with a shared object before any other shared objects.

# Symbol Visibility

symbol is the corresponding entity of most user-defined variables, function names, 
mangled with namespace, class/struct/name, and so on.

> Symbol visibility comes to be an attribute for all global symbols for dynamic linking.

For library security, dynamic linking performance and avoiding symbol collision, 
one may limit visible exported symbols.

`static` and `extern` keywords are provided at language level to control visibility of variables and functions at *translation-unit level*. They are not suited for low-level symbol control.

ELF defines several symbol visibility levels:

- *STV_DEFAULT* `__attribute__((visibility ("default")))`: visible and overridable

- *STV_PROTECTED* `__attribute__((visibility ("protected")))`: visible outside the current executable or sharedd object, but not overridable

- *STV_HIDDEN* `__attribute__((visibility ("hidden")))`: Not visible to other components, shareable among translation units. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.
Still accessible if its address is passed outside.

- *STV_INTERNAL* `__attribute__((visibility ("internal")))`: not accessible outside the current executable or shared library, never called from another module.

