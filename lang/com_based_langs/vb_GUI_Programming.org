#+title: VB Classic Gui Programming

in VB6, controls can be classified into (1) /Standard Controls/, managed by the
Windows OS, and the (2) /Lightweight Controls/, handled by the VB runtime itself.

* IDE & Designer

- Ctrl + drag to place a control multiple times

- select a control, use Ctrl + Arrow to move and Shift + Arrow to resize.

- Use Ctrl-Shift-Initial to quickly locate a property.

- the Format menu are used to align, resize controls.

- One can evaluate an expression by typing in the immediate window, prefixed with =?=.

* Form Properties

- =Tag=: VB extender properties that is always available, no specific use,
  stores any object related to that control.

- =hWnd=: the internal handle used by Windows to identify a control, available
  only to standard Windows controls.

- =Enabled=, =Visible=: disabled controls don't react to user's actions.
  Invisible controls are automatically disabled. 
  All mouse events for disabled or invisible controls are passed to the underlying container or to the form itself.

* Form Methods

- =SetFocus=: raises a runtime error if the control is currently dissabled or invisible, e.g. in the =Form_Load= event.

- =ZOrder=: standard controls are always  placed before lightweight  controls.

* Form Lifecycle

1. =Initialize=: triggered where variables are initialized; before the actual window and the
   controls are created

2. =Load=: triggered when properties and controls are referenced. The windows
   and its child controls have been created. Graphical operations will not work.
   A form is only visible after its =Show= method is called.

3. =Resize=: visible or sized changed

4. =Activate=: ready to accept user input

5. =Deactivate=: end user switches to another form

6. =Paint=: the form refreshes itself (fired only if =AutoRedraw= is =False=).
   The user is expected to redraw the form's contents using graphic methods.
   + executed whenever the form needs to be refreshed: on resizing, recovering from being covered.
     It does not fire upon shrinking.
   + the first =Paint= occurs immediately after the =Activate= event.

7. =QueryUnload=: =OnClosing=

#+begin_src vba
' refuse to unload
Private Sub Form_QueryUnload(Cancel As Integer, _
    UnloadMode As Integer)
    ' Don't let the user close this form.
    Select Case UnloadMode
        Case vbFormControlMenu, vbAppTaskManager
            Cancel = True
    End Select
End Sub
#+end_src

8. =Unload=: a last chance to prevent the close of the form
  + the form will be destroyed after this event.

#+begin_src vba
' This is a module-level variable.
Dim Saved As Boolean

Private Sub Form_Unload(Cancel As Integer)
    If Not Saved Then
        MsgBox "Please save data first!"
        Cancel = True
    End If
End Sub
#+end_src

9. =Terminate=: cleanup code.
  + By the time this event is raised, the form has already been destroyed.

* Control Events

- =Click=, =DblClick=: triggered not only by actual mouse clicks but also code, 
  and possibly by some actions more than clicking: value change in an =OptionButto= or a =CheckBox=,
  selected index change of a =ListBox= or a =ComboBox=.
  + When a control is double-clicked, both events are raised.
  + =CommandButton= has no =DblClick=
  #+begin_src vba
' A module-level variable
Dim isClick As Boolean

Private Sub Form_Click()
    Dim t As Single
    isClick = True
    ' Wait for the second click for half a second.
    t = Timer
    Do
        DoEvents
        ' If the DblClick procedure canceled this event, 
        ' bail out.
        If Not isClick Then Exit Sub
        ' The next test accounts for clicks 
    Loop Until Timer > t + .5 Or Timer < t
    ' Do your single-click processing here.
    ...
End Sub

Private Sub Form_DblClick()
    ' Cancel any pending click.
    isClick = False
    ' Do your double-click processing here.
    ...
End Sub  
  #+end_src

- =GetFocus=, =LostFocus=: not suitable for validation due to their fire order.
  + Forms have both but only fire them when no control can receive the input focus.
  + Use the =Validate= event for validation.

- =Change=: its behavior is not consistent across VB controls. Not available for =CheckBox= and =OptionButton=, which fires a
  =Click= event when its content is changed.

- =KeyPress=, =KeyDown= (the key translated into ANSI numeric code), =KeyUp=: Only keys 
  that correspond to control keys (Ctrl+x, BackSpace, Enter, and Escape) 
  and printable characters activate the =KeyPress= event.
  + order: =KeyDown=, =KeyPress=, =KeyUp=
  + the key code in =KeyPress= may be changed to affect how the program interprets the key.
  + The =KeyPreview= property of a form lets the form receive all key events before any of the contained control.

- =MouseDown=, =MouseUp=, =MouseMove=: mouse button state, Shift/Ctrl/Alt state
  and the cursor's location are passed.
  + if the mouse is captured by a control, =MouseUp= is raised when and the mouse is released 
    and may receive negative coordinates.
  + for a single click: =MouseDown=, =DownUp=, =Click=, =MouseMove=
  + for a double click: =MouseDown=, =MouseUp=, =Click=, =MouseMove=, =DblClick=, =MouseUp=, =MouseMove=,
    there is no second =MouseDown=

* The =AutoRedraw= Property

By default =False= for performance.

Whether a form is backed up by a persistent bitmap (as large as the largest size for the form, screen size for resizable forms) 
so that when it's covered by another form and then uncovered, it can be quickly restored from the bitmap.

* The =Controls= Collection

Container of all the controls currently loaded on the form itself.

#+begin_src vba
Dim ctrl As Control
On Error Resume Next
For Each ctrl In Controls
    ctrl.Text = ""
Next
#+end_src

* Tab order and Hotkey (Alt + Initial)

Set a label's tabindex one smaller than that of the control to activate.

There'is an add-in that comes with VB IDE called =TabOrder.vbp= that can
automatically set tab orders.
